<?php
namespace Makis83\Helpers;

use tidy;
use HTMLPurifier;
use RuntimeException;
use Safe\Exceptions\SafeExceptionInterface;

/**
 * Provides HTML related helper methods.
 * Created by PhpStorm.
 * User: max
 * Date: 2025-09-15
 * Time: 15:20
 */
class Html
{
    /**
     * Detect whether the text is an HTML code.
     *
     * @param string $text Text to check
     * @return boolean Whether the text is an HTML code
     */
    public static function isHTML(string $text): bool
    {
        // Validate
        if ('' === trim($text)) {
            return false;
        }

        // Result
        return $text !== strip_tags($text);
    }


    /**
     * Secure the specified text data.
     *
     * @param string $data Simple text or HTML code
     * @param bool $forceHtml Whether to force HTML output even if text is not an HTML
     * @param bool $purify Whether to purify the HTML (makes the code safer and standard-compliant)
     * @param null|string $charset Character set (default is application charset)
     * @return string processed string
     */
    public static function secure(
        string $data,
        bool $forceHtml = true,
        bool $purify = true,
        ?string $charset = null
    ): string {
        // Validate input data
        if ('' === trim($data)) {
            return '';
        }

        // Check if specified data is an HTML
        $isHtml = static::isHTML($data);

        // Get charset
        if (null === $charset) {
            try {
                $charset = \Safe\ini_get('default_charset');
            } catch(SafeExceptionInterface) {
                $charset = 'UTF-8';
            }
        }

        // Convert all entities to text chars if the text is not an HTML
        if (!$isHtml && !$forceHtml) {
            return html_entity_decode(htmlentities($data, ENT_QUOTES, $charset, false));
        }

        // Purify HTML
        if ($purify && $isHtml) {
            $oPurifier = new HTMLPurifier();
            $data = $oPurifier->purify($data);
        }

        // Convert all entities to simple chars
        $text = html_entity_decode($data, ENT_QUOTES | ENT_HTML5, $charset);

        // Convert all applicable characters to HTML entities
        return htmlentities($text);
    }


    /**
     * Tidy the specified HTML code.
     *
     * @param string $html HTML code
     * @param boolean $repair Whether to repair the possibly broken HTML
     * @param null|string $charset Character set (default is application charset)
     * @return string HTML code
     * @see http://api.html-tidy.org/tidy/quickref_5.0.0.html
     * @throws RuntimeException if Tidy extension is not loaded
     */
    public static function tidy(string $html, bool $repair = true, ?string $charset = null): string
    {
        // Validate
        if ('' === trim(strip_tags($html))) {
            return '';
        }

        // Get charset
        if (null === $charset) {
            try {
                $charset = \Safe\ini_get('default_charset');
            } catch(SafeExceptionInterface) {
                $charset = 'UTF-8';
            }
        }

        // Check if the text is not an HTML
        if (!static::isHTML($html)) {
            return static::secure($html, charset: $charset);
        }

        // Check if Tidy extension is loaded
        if (!extension_loaded('tidy')) {
            throw new RuntimeException('Tidy extension is not loaded');
        }

        // Define config array
        $config = array(
            'bare' => true,
            // strip Microsoft specific HTML from Word 2000 documents
            'clean' => true,
            // strip out surplus presentational tags and attributes replacing them by style rules and structural markup as appropriate
            'coerce-endtags' => true,
            // if Tidy should coerce a start tag into an end tag in cases where it looks like an end tag was probably intended; for example, given <span>foo <b>bar<b> baz</span>, Tidy will output <span>foo <b>bar</b> baz</span>
            'doctype' => 'omit',
            // specifies the DOCTYPE declaration generated by Tidy
            'drop-empty-elements' => true,
            // if Tidy should discard empty elements
            'drop-empty-paras' => true,
            // if Tidy should discard empty paragraphs
            // 'drop-font-tags' => true, // if Tidy should discard <FONT> and <CENTER> tags without creating the corresponding style rules
            'drop-proprietary-attributes' => true,
            // if Tidy should strip out proprietary attributes, such as MS data binding attributes
            'hide-comments' => true,
            // if Tidy should print out comments
            'indent' => false,
            // this option specifies if Tidy should indent block-level tags
            'indent-spaces' => 4,
            // specify the number of spaces Tidy uses to indent content, when indentation is enabled
            'input-encoding' => 'utf8',
            // specify the character encoding Tidy uses for the input
            'join-classes' => true,
            // specifies if Tidy should combine class names to generate a single new class name, if multiple class assignments are detected on an element
            'logical-emphasis' => true,
            // if Tidy should replace any occurrence of <I> by <EM> and any occurrence of <B> by <STRONG>
            'new-blocklevel-tags' => 'article aside audio bdi canvas details dialog figcaption figure footer header hgroup main menu menuitem nav section source summary template track video',
            'new-empty-tags' => 'command embed keygen source track wbr',
            'new-inline-tags' => 'audio command datalist embed keygen mark menuitem meter output progress source time video wbr',
            'output-encoding' => 'utf8',
            // specifies the character encoding Tidy uses for the output
            'output-xhtml' => true,
            // specifies if Tidy should generate pretty printed output, writing it as extensible HTML
            'preserve-entities' => true,
            // if Tidy should preserve the well-formed entitites as found in the input
            'show-body-only' => true,
            // if Tidy should print only the contents of the body tag as an HTML fragment
            'tidy-mark' => false,
            'word-2000' => true,
            // if Tidy should go to great pains to strip out all the surplus stuff Microsoft Word 2000 inserts when you save Word documents as "Web pages"
            'wrap' => 0
        );

        // Parse
        $tidy = new Tidy;
        $tidy->parseString($html, $config, 'utf8');

        // Try to repair
        if ($repair) {
            $tidy->cleanRepair();
        }

        // Result
        return tidy_get_output($tidy);
    }


    /**
     * Convert a plain text into HTML.
     *
     * @param string $text plain text
     * @param null|string $charset Character set (default is application charset)
     * @return string HTML code
     */
    public static function textToHtml(string $text, ?string $charset = null): string
    {
        // Check if text is empty
        if ('' === trim($text)) {
            return '';
        }

        // Check if this text is already HTML
        if (static::isHTML($text)) {
            return $text;
        }

        // Get charset
        if (null === $charset) {
            try {
                $charset = \Safe\ini_get('default_charset');
            } catch(SafeExceptionInterface) {
                $charset = 'UTF-8';
            }
        }

        // Normalize line endings
        $text = str_replace(["\r\n", "\r"], "\n", $text);

        // Split text into paragraphs
        try {
            $paragraphs = \Safe\preg_split('/\n\s*\n/', $text, -1, PREG_SPLIT_NO_EMPTY);
        } catch (SafeExceptionInterface) {
            return $text;
        }

        // Process each paragraph
        $html = array_map(static function(string $paragraph) use ($charset): string {
            // Trim whitespace
            $paragraph = trim($paragraph);

            // Replace single newlines with <br>
            $paragraph = nl2br(htmlspecialchars($paragraph, ENT_QUOTES, $charset));

            // Wrap in <p> tags
            return "<p>$paragraph</p>";
        }, $paragraphs);

        // Join paragraphs and return
        return static::tidy(implode("\n", $html));
    }


    /**
     * Get HTML tags used in the text.
     * @param string $text text
     * @return string[] array of used HTML tags
     */
    public static function textTags(string $text): array {
        // Check if text is not an HTML
        if (!static::isHTML($text)) {
            return [];
        }

        // Try to get tags from content
        try {
            // Match all HTML tags, including those with attributes
            \Safe\preg_match_all('/<\/?([a-z][a-z0-9]*)\b[^>]*>/i', $text, $matches);

            // Get unique tag names (case-insensitive)
            return array_keys(array_flip(array_map('strtolower', $matches[1])));
        } catch(SafeExceptionInterface) {
            return [];
        }
    }
}
